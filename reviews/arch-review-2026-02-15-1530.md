# Architecture Review — 2026-02-15

## System Overview

Settlers.ts is a Settlers 4 remake with a clean layered architecture: pure data types at the bottom, algorithms above, features/systems in the middle, and glue/I/O at the top. The engine uses a fixed-timestep game loop with registered `TickSystem` components, an event bus for decoupling, and a Manager/System split for complex features. State flows through commands → state mutation + events → system reactions → rendering queries. The architecture is already well-documented in `docs/design-rules.md` and `docs/architecture/feature-modules.md`.

## Strengths

### 1. Clear Layer Architecture
The dependency direction rules (Layer 0→6) prevent circular imports and make the codebase navigable. Pure algorithm modules have zero game imports, enabling reuse and isolated testing.

### 2. Feature Module Pattern
The `features/*/index.ts` entry point pattern with `internal/` for private implementation is excellent. Features are self-contained — removing one means deleting a folder and removing registrations.

### 3. Event-Driven Decoupling
Events like `building:created`, `carrier:jobAssigned`, and `entity:removed` allow features to react without direct coupling. The typed `GameEvents` interface provides compile-time safety.

### 4. Error Isolation & Circuit Breaker
Each `TickSystem` has independent error tracking, throttled logging, and automatic disabling after 100 consecutive failures. One bad system doesn't crash the game.

### 5. Entity-Owned State (RFC Pattern)
Per-entity state (`entity.tree`, `entity.carrier`, `entity.production`) lives on the entity itself rather than in scattered Maps. This simplifies cleanup (remove entity = remove all state) and improves cache locality.

### 6. Config Object Pattern
Systems with 3+ dependencies use named config objects, making construction self-documenting and order-independent.

---

## Critical Issues

### Issue 1: GameLoop is a God Object

**Impact:** The `GameLoop` constructor is 140+ lines of manual wiring. Adding a new feature requires editing this file, understanding the initialization order, and ensuring dependencies are created first. This slows down feature development and increases error risk.

**Current state:** `game-loop.ts` lines 147-286:
- Creates 9 managers manually
- Creates 8+ systems manually
- Sets entity providers manually
- Wires event subscriptions inline
- Hard-codes system execution order in comments
- Handles `building:created`, `mapObject:created`, `entity:removed` events inline

**Recommended direction:**
1. **Feature Registry Pattern**: Features register themselves with metadata (dependencies, events, execution priority)
2. **Dependency Injection Container**: Auto-resolve dependencies based on type annotations or config
3. **Declarative System Order**: Use numeric priorities or dependency graph instead of constructor order

Target structure:
```typescript
// Feature declares its requirements
export const CarrierFeature = defineFeature({
  id: 'carriers',
  managers: [CarrierManager],
  systems: [CarrierSystem],
  requires: ['inventory', 'service-areas'],  // other features
  priority: 30,  // execution order
  events: {
    'building:created': handleBuildingCreated,
    'entity:removed': handleCarrierRemoved,
  },
});

// GameLoop just loads features
gameLoop.loadFeatures([CarrierFeature, LogisticsFeature, ...]);
```

---

### Issue 2: Event Subscription Lifecycle is Manual and Fragile

**Impact:** Each system must manually implement `registerEvents()` and `unregisterEvents()`. Missing cleanup causes memory leaks on HMR reloads. Different systems implement this inconsistently.

**Current state:**
- `CarrierSystem.registerEvents()` — 3 event subscriptions
- `LogisticsDispatcher.registerEvents()` — 4 event subscriptions
- `BuildingConstructionSystem.registerEvents()` — 2 event subscriptions
- Some use `EventSubscriptionManager` helper, some don't
- `unregisterEvents()` often missing or incomplete

**Recommended direction:**
1. **Subscription Manager as Standard**: Every system that uses events MUST use `EventSubscriptionManager`
2. **Automatic Unsubscription**: GameLoop calls `system.destroy()` which auto-unsubscribes
3. **Declarative Event Binding**: Events declared in feature config, auto-subscribed on registration

```typescript
class CarrierSystem implements TickSystem {
  private subs = new EventSubscriptionManager();

  registerEvents(eventBus: EventBus): void {
    this.subs.add(eventBus, 'building:created', this.onBuildingCreated);
    this.subs.add(eventBus, 'carrier:jobCompleted', this.onJobCompleted);
  }

  destroy(): void {
    this.subs.unsubscribeAll();  // Always called by GameLoop
  }
}
```

---

### Issue 3: No Formal Interface Between Renderer and Game State

**Impact:** The renderer reaches deep into game internals via callbacks, making it hard to test or optimize. Adding a new visual feature requires understanding both renderer internals and game state structure.

**Current state:** `use-renderer.ts` lines 50-80:
- Accesses `g.gameLoop.buildingStateManager`
- Accesses `g.state.entities`
- Creates its own `InputManager` internally
- Passes 10+ parameters to `EntityRenderer.draw()`

**Recommended direction:** Introduce a `RenderContext` interface (already mentioned in `design-rules.md` Rule 6.3):

```typescript
interface RenderContext {
  entities: ReadonlyArray<Entity>;
  unitStates: UnitStateLookup;
  buildingVisualState(entityId: number): BuildingVisualState;
  animationData: AnimationDataProvider;
  camera: IViewPoint;
  selection: ReadonlySet<number>;
}

// GameLoop builds RenderContext once per frame
const ctx = gameLoop.buildRenderContext();
renderer.draw(ctx);
```

Benefits:
- Renderer tested with mock context
- Clear contract between game logic and rendering
- Single place to add new render data

---

### Issue 4: Manager/System Wiring Creates Implicit Dependencies

**Impact:** Some managers need `setEntityProvider()`, some need `setEventBus()`, some need both. It's easy to forget a call, causing runtime errors when an entity lookup fails.

**Current state:** `game-loop.ts` lines 167-231:
```typescript
this.buildingStateManager.setEntityProvider(gameState);
this.carrierManager.setEntityProvider(gameState);
// ...
this.carrierSystem.setSettlerTaskSystem(this.settlerTaskSystem);
```

These setter calls are required but not enforced by types. Forgetting one causes a crash later.

**Recommended direction:**
1. **Required in Constructor**: If a manager needs entity lookup, require `EntityProvider` in constructor
2. **Type Enforcement**: Use `Required<T>` for dependencies that MUST be set
3. **Initialization Validation**: Add `assertInitialized()` check before first tick

```typescript
class CarrierManager {
  constructor(private entityProvider: EntityProvider) {}  // Always required
}

// No setEntityProvider() call needed — enforced at construction time
```

---

## Recommended Restructuring

### Refactor 1: Feature Self-Registration System

**Scope:** `game-loop.ts`, all feature modules, new `features/feature-registry.ts`

**Rationale:** Currently GameLoop manually instantiates and wires every system. This creates:
- Bloated constructor with implicit ordering
- No way to conditionally load features
- Hard to test features in isolation

**Target state:**
```
features/
  feature-registry.ts      # defineFeature(), FeatureLoader
  carriers/
    index.ts               # exports CarrierFeature
    feature.ts             # defineFeature({ id, managers, systems, events })
  logistics/
    feature.ts
  ...

game-loop.ts
  constructor() {
    this.registry = new FeatureRegistry();
    this.registry.loadAll([
      CarrierFeature,
      LogisticsFeature,
      BuildingConstructionFeature,
    ]);
  }
```

**Dependencies:**
- Define `Feature` interface with metadata
- Implement topological sort for dependency ordering
- Migrate one feature at a time (start with simplest: `tree-system`)

---

### Refactor 2: RenderContext Facade

**Scope:** `use-renderer.ts`, `renderer/`, `entity-renderer.ts`

**Rationale:** Renderers currently receive 10+ parameters and reach into game state. This makes rendering logic tightly coupled to internal structures.

**Target state:**
```typescript
// game-loop.ts
public buildRenderContext(): RenderContext {
  return {
    entities: this.gameState.entities,
    getUnitState: (id) => this.gameState.movement.getUnitState(id),
    getBuildingVisualState: (id) => getBuildingVisualState(id, this.buildingStateManager),
    animations: this.animationService,
    camera: this.viewPoint,
    selection: this.gameState.selectedEntityIds,
  };
}

// EntityRenderer.ts
draw(ctx: RenderContext): void {
  for (const entity of ctx.entities) {
    const visual = ctx.getBuildingVisualState(entity.id);
    // ...
  }
}
```

**Dependencies:**
- Define `RenderContext` interface in `renderer/types.ts`
- Update `EntityRenderer`, `LandscapeRenderer`, `SelectionOverlayRenderer`
- Keep backward compatibility during migration

---

### Refactor 3: Standardize Manager Constructor Patterns

**Scope:** All `*Manager` classes

**Rationale:** Inconsistent initialization patterns (some use constructors, some use setters) create implicit ordering requirements that aren't caught by the type system.

**Target state:**
- All managers receive required dependencies via constructor
- Optional dependencies use a config object with defaults
- No `set*()` methods for required dependencies

```typescript
// Before
class CarrierManager {
  private entityProvider?: EntityProvider;
  setEntityProvider(ep: EntityProvider) { this.entityProvider = ep; }
}

// After
class CarrierManager {
  constructor(private entityProvider: EntityProvider) {}
}
```

**Dependencies:**
- Audit all managers for `set*()` methods
- Refactor one at a time, update GameLoop constructor
- Add runtime assertion for any remaining optional providers

---

### Refactor 4: Declarative Event Subscriptions

**Scope:** All systems with `registerEvents()`, `event-bus.ts`

**Rationale:** Manual event subscription is error-prone. Forgetting to unsubscribe causes memory leaks. The pattern varies between systems.

**Target state:**
```typescript
// Option A: Decorator-based
class CarrierSystem {
  @OnEvent('building:created')
  handleBuildingCreated(payload: BuildingCreatedEvent) { ... }

  @OnEvent('entity:removed')
  handleEntityRemoved(payload: EntityRemovedEvent) { ... }
}

// Option B: Static declaration
static readonly events = {
  'building:created': 'handleBuildingCreated',
  'entity:removed': 'handleEntityRemoved',
} as const;
```

**Dependencies:**
- Extend `TickSystem` interface or create `EventAwareSystem`
- GameLoop auto-subscribes based on metadata
- Auto-unsubscribe on system destruction

---

## Medium-Priority Improvements

### 1. Command Result Types

**Current:** Commands return `boolean` (success/failure).
**Better:** Commands return `{ success: boolean, error?: string, effects?: [] }` for debugging and replay.

### 2. System Execution Profiling

**Current:** Debug stats show aggregate tick time.
**Better:** Per-system timing breakdown to identify bottlenecks.

### 3. Feature Hot-Reloading (Dev Mode)

**Current:** HMR reloads entire game.
**Better:** Feature registry allows unloading/reloading individual features without full reset.

### 4. Typed State Transitions

**Current:** State machines (carrier status, construction phase) use enums and if/else.
**Better:** Use state machine library with typed transitions, preventing invalid state changes.

---

## Questions for the Team

1. **Feature Flags**: Should features be conditionally loadable (e.g., disable military units during testing)? This affects the registry design.

2. **Determinism vs Performance**: The design rules require deterministic iteration order (sorted IDs). Should we accept the sort overhead, or use insertion-order Maps with deterministic insertion?

3. **Render Context Scope**: Should `RenderContext` include debug overlay data, or should debug rendering be a separate system?

4. **Event Payload Size**: Events include full context (e.g., `buildingState` object). Should we switch to IDs + query functions to reduce memory pressure?

5. **Test Isolation**: Should unit tests be able to instantiate features without GameLoop? This affects how dependencies are provided.

---

## Implementation Priority

| Refactor | Effort | Impact | Suggested Order |
|----------|--------|--------|-----------------|
| Manager Constructor Patterns | Low | Medium | 1st — quick wins, reduces bugs |
| Event Subscription Standardization | Medium | Medium | 2nd — prevents memory leaks |
| RenderContext Facade | Medium | High | 3rd — unlocks render testing |
| Feature Self-Registration | High | Very High | 4th — major structural change |

Start with low-effort, high-impact changes. The Feature Registry is the biggest improvement but should be done last after other patterns are standardized.
